处理tcp 传输过程中出现的粘包和拆包的问题
粘包和拆包出现的原因:
    TCP是个“流”协议，所谓流，就是没有界限的一串数据。TCP底层并不了解业务数据的具体含义，它会根据TCP缓存区的实际情况进行包的划分，
    所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也可能把多个小包合并成一个大包发送，这就是所谓的粘包和拆包的问题
    举例说明:
        假设TCP 客户端分别发送两个数据包 D1 和 D2给服务器，由于服务区一次读取到的字节数是不一定的，所以会出现下面几种情况:
            1. TCP 服务器端分两次读取到了两个独立的数据包 D1 和 D2 ,没有粘包和拆包
            2. TCP 服务器一次读取的两个数据包,D1和D2粘在一起，被称为粘包
            3. TCP 服务器 分两次读取 第一次读取了 D1 和D2_1(D2的一部分) ，第二次读取了 D2_2 (D2 包剩余的部分)，被称为拆包
            ...
            以上还有其他情况就不一一列举了
粘包和拆包的解决思路:
    1.消息固定长度,累计读取到长度总和为定长LEN的报文就认为读取到了一个完整的消息，将计数器重置，重新开始读取下一个数据报文
    2.将回车换位符作为消息结束符
    3.将特殊的分隔符作为消息的结束标志
    4.通过消息头中定义字段长度来标识消息的长度
netty中提供了对应的粘包方案:
    1.消息固定长度 --> io.netty.handler.codec.FixedLengthFrameDecoder
    2.将回车换位符作为消息的结束符 --> io.netty.handler.codec.LineBasedFrameDecoder
